# SCIP_PARAMSETTING_FAST
heuristics/coefdiving/freq = -1
heuristics/crossover/freq = -1
heuristics/feaspump/freq = -1
heuristics/fracdiving/freq = -1
heuristics/guideddiving/freq = -1
heuristics/linesearchdiving/freq = -1
heuristics/nlpdiving/freq = -1
heuristics/subnlp/freq = -1
heuristics/objpscostdiving/freq = -1
heuristics/pscostdiving/freq = -1
heuristics/rens/freq = -1
heuristics/rootsoldiving/freq = -1
heuristics/undercover/freq = -1
heuristics/veclendiving/freq = -1
# turn this one on
heuristics/shiftandpropagate/freq = 1

# turning off some separators
separating/clique/freq = -1
separating/flowcover/freq = -1
separating/impliedbounds/freq = -1
separating/intobj/freq = -1
separating/mcf/freq = -1

# row norm to use for efficacy calculation ('e'uclidean, 'm'aximum, 's'um, 'd'iscrete)
# [type: char, range: {emsd}, default: e]
separating/efficacynorm = d

# maximal number of consecutive separation rounds without objective or integrality improvement (-1: no additional restriction)
# [type: int, range: [-1,2147483647], default: 5]
separating/maxstallrounds = 50

# maximal number of separated cuts at the root node (0: disable root node separation)
# [type: int, range: [0,2147483647], default: 2000]
separating/maxcutsroot = 2000000

# separation frequency for the global cut pool (-1: disable global cut pool, 0: only separate pool at the root)
# [type: int, range: [-1,2147483647], default: 0]
separating/poolfreq = 1


# child selection rule ('d'own, 'u'p, 'p'seudo costs, 'i'nference, 'l'p value, 'r'oot LP value difference, 'h'ybrid inference/root LP value difference)
# [type: char, range: {dupilrh}, default: h]
nodeselection/childsel = u

# maximal number of restarts (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
presolving/maxrestarts = 0

# default clock type (1: CPU user seconds, 2: wall clock time)
# [type: int, range: [1,2], default: 1]
timing/clocktype = 2


#################################
# DISPLAY
#################################

# display activation status of display column <depth> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/depth/active = 2

# display activation status of display column <vars> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/vars/active = 0

# display activation status of display column <poolsize> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/poolsize/active = 2

# display activation status of display column <lpavgiterations> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/lpavgiterations/active = 0

#################################
# EXPERIMENTAL
#################################

# whether to print solving statistics
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
#gobnilp/printstatistics = TRUE

#gobnilp/dagconstraintsfile = "example.constraints"

#gobnilp/outputfile/cip = "foo.cip"

##################################
# PARAMETERS FOR ACTIVE SEPARATORS
##################################

# CLOSECUTS

separating/closecuts/freq = 0
# generate close cuts w.r.t. relative interior point (best solution otherwise)?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/closecuts/separelint = FALSE

# ODDCYCLE

separating/oddcycle/freq = 0


# GOMORY

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <gomory> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/gomory/maxbounddist = 1

# maximal number of gomory separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/gomory/maxrounds = -1

# maximal number of gomory separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/gomory/maxroundsroot = -1

# maximal valid range max(|weights|)/min(|weights|) of row weights
# [type: real, range: [1,1.79769313486232e+308], default: 10000]
separating/gomory/maxweightrange = 1.79769313486232e+308


# ZEROHALF

# frequency for calling separator <zerohalf> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
separating/zerohalf/freq = 0

# maximal number of zerohalf separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/zerohalf/maxrounds = -1

# maximal number of zerohalf separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/zerohalf/maxroundsroot = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <zerohalf> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/zerohalf/maxbounddist = 1

# maximal number of different deltas to try for cmir (-1: unlimited, 0: delta=1)
# [type: int, range: [-1,2147483647], default: 10]
separating/zerohalf/maxtestdelta = -1

# minimal violation of a {0,1/2}-cut to be separated
# [type: real, range: [0.001,0.5], default: 0.3]
separating/zerohalf/separating/minviolation = 0.001

